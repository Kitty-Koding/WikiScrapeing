<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Wikipedia Link Graph Explorer</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 1em; }
    input, button { padding: 0.5em; margin: 0.5em 0; }
    label { display: block; margin-top: 1em; }
    #status { margin: .5em 0; color: #555; }
    svg { width: 100%; height: 80vh; border: 1px solid #ccc; }
  </style>
</head>
<body>
  <h1>Wikipedia Link Graph Explorer</h1>

  <label>
    Starting page:
    <input type="text" id="startPage" placeholder="e.g. JavaScript">
  </label>
  <label>
    Depth (2–6):
    <input type="range" id="depthSlider" min="2" max="6" value="2">
    <span id="depthValue">2</span>
  </label>
  <button id="goBtn">Generate Graph</button>
  <div id="status">Idle.</div>

  <svg id="graph"></svg>

  <!-- D3 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    // UI refs
    const depthSlider = document.getElementById('depthSlider');
    const depthValue  = document.getElementById('depthValue');
    const statusEl    = document.getElementById('status');
    const goBtn       = document.getElementById('goBtn');
    const svgEl       = d3.select('#graph');

    depthSlider.addEventListener('input', () => {
      depthValue.textContent = depthSlider.value;
    });

    // Crawler state
    let nodesMap, links;

    async function fetchLinks(title) {
      const encoded = encodeURIComponent(title);
      let cont = '';
      let all = [];
      do {
        const url =
          `https://en.wikipedia.org/w/api.php` +
          `?action=query&prop=links&titles=${encoded}` +
          `&pllimit=max&format=json&origin=*${cont}`;
        const res = await fetch(url);
        const j   = await res.json();
        const page = Object.values(j.query.pages)[0];
        if (page.links) {
          all.push(
            ...page.links
              .map(l => l.title)
              .filter(t => !/^(Category|Wikipedia|Help|File|Portal|Special|Template):/.test(t))
          );
        }
        cont = j.continue ? `&plcontinue=${j.continue.plcontinue}` : '';
      } while (cont);
      return Array.from(new Set(all));
    }

    async function crawl(start, maxDepth) {
      statusEl.textContent = 'Crawling…';
      // reset
      nodesMap = new Map();
      links    = [];
      const visited = new Set();
      const queue = [{ title: start, depth: 0 }];

      // seed the start node
      nodesMap.set(start, { id: start, group: 0 });

      while (queue.length) {
        const { title, depth } = queue.shift();
        if (depth > maxDepth) continue;
        if (visited.has(title))       continue;
        visited.add(title);

        statusEl.textContent = `Fetching "${title}" at depth ${depth}…`;
        const neigh = await fetchLinks(title);

        for (const tgt of neigh) {
          // ensure target node exists (so every link has a node)
          if (!nodesMap.has(tgt)) {
            nodesMap.set(tgt, { id: tgt, group: depth + 1 });
          }
          links.push({ source: title, target: tgt });
          // only enqueue if we still have depth budget
          if (depth < maxDepth) {
            queue.push({ title: tgt, depth: depth + 1 });
          }
        }
      }
      statusEl.textContent = `Done: ${nodesMap.size} nodes, ${links.length} links.`;
    }

    function draw() {
      statusEl.textContent = 'Rendering graph…';
      const nodesArr = Array.from(nodesMap.values());
      const width  = +svgEl.node().clientWidth;
      const height = +svgEl.node().clientHeight;
      const color  = d3.scaleOrdinal(d3.schemeCategory10);

      const sim = d3.forceSimulation(nodesArr)
        .force('link', d3.forceLink(links).id(d => d.id).distance(60))
        .force('charge', d3.forceManyBody().strength(-120))
        .force('center', d3.forceCenter(width/2, height/2));

      svgEl.selectAll('*').remove();

      const link = svgEl.append('g')
          .attr('stroke','#aaa')
        .selectAll('line')
        .data(links)
        .join('line');

      const node = svgEl.append('g')
          .attr('stroke','#fff').attr('stroke-width',1.5)
        .selectAll('circle')
        .data(nodesArr)
        .join('circle')
          .attr('r', 6)
          .attr('fill', d => color(d.group))
          .call(d3.drag()
            .on('start', (e,d) => {
              if (!e.active) sim.alphaTarget(0.3).restart();
              d.fx = d.x; d.fy = d.y;
            })
            .on('drag', (e,d) => { d.fx = e.x; d.fy = e.y; })
            .on('end',  (e,d) => {
              if (!e.active) sim.alphaTarget(0);
              d.fx = null; d.fy = null;
            }));

      const label = svgEl.append('g')
        .selectAll('text')
        .data(nodesArr)
        .join('text')
          .text(d => d.id)
          .attr('font-size','9px')
          .attr('dx',8)
          .attr('dy',4);

      sim.on('tick', () => {
        link
          .attr('x1', d=>d.source.x)
          .attr('y1', d=>d.source.y)
          .attr('x2', d=>d.target.x)
          .attr('y2', d=>d.target.y);
        node
          .attr('cx', d=>d.x)
          .attr('cy', d=>d.y);
        label
          .attr('x', d=>d.x)
          .attr('y', d=>d.y);
      });
      statusEl.textContent = 'Graph ready.';
    }

    goBtn.addEventListener('click', async () => {
      const start = document.getElementById('startPage').value.trim();
      const depth = +depthSlider.value;
      if (!start) { alert('Enter a start page.'); return; }
      await crawl(start, depth);
      draw();
    });
  </script>
</body>
</html>
