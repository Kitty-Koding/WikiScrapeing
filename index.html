<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Wikipedia Link Graph Explorer</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 1em; }
    input, button { padding: 0.5em; margin: 0.5em 0; }
    label { display: block; margin-top: 1em; }
    #status { margin: .5em 0; color: #555; }
    svg { width: 100%; height: 80vh; border: 1px solid #ccc; }
    /* Tooltip styling */
    #tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px;
      border: 1px solid #999;
      border-radius: 4px;
      font-size: 12px;
      display: none;
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <h1>Wikipedia Link Graph Explorer</h1>

  <label>
    Starting page:
    <input type="text" id="startPage" placeholder="e.g. JavaScript">
  </label>
  <label>
    Depth (2–6):
    <input type="range" id="depthSlider" min="2" max="6" value="2">
    <span id="depthValue">2</span>
  </label>
  <button id="goBtn">Generate Graph</button>
  <div id="status">Idle.</div>

  <div id="tooltip"></div>
  <svg id="graph"></svg>

  <!-- D3 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    const depthSlider = document.getElementById('depthSlider');
    const depthValue  = document.getElementById('depthValue');
    const statusEl    = document.getElementById('status');
    const goBtn       = document.getElementById('goBtn');
    const tooltipEl   = d3.select('#tooltip');
    const svg         = d3.select('#graph');
    const container   = svg.append('g');  // all graph elements go here

    depthSlider.addEventListener('input', () => {
      depthValue.textContent = depthSlider.value;
    });

    // Zoom behavior
    svg.call(d3.zoom()
      .scaleExtent([0.1, 4])
      .on('zoom', ({transform}) => container.attr('transform', transform)));

    // Fetch & crawl as before…
    async function fetchLinks(title) {
      const enc = encodeURIComponent(title), all = [];
      let cont = '';
      do {
        const url = `https://en.wikipedia.org/w/api.php` +
                    `?action=query&prop=links&titles=${enc}` +
                    `&pllimit=max&format=json&origin=*${cont}`;
        const j = await (await fetch(url)).json();
        const p = Object.values(j.query.pages)[0];
        if (p.links) {
          p.links.forEach(l => {
            if (!/^(Category|Wikipedia|Help|File|Portal|Special|Template):/.test(l.title))
              all.push(l.title);
          });
        }
        cont = j.continue ? `&plcontinue=${j.continue.plcontinue}` : '';
      } while (cont);
      return Array.from(new Set(all));
    }

    async function crawl(start, maxDepth) {
      statusEl.textContent = 'Crawling…';
      const nodesMap = new Map(), links = [];
      const visited = new Set(), queue = [{title: start, depth: 0}];
      nodesMap.set(start, {id: start, group: 0});

      while (queue.length) {
        const {title, depth} = queue.shift();
        if (depth > maxDepth || visited.has(title)) continue;
        visited.add(title);
        statusEl.textContent = `Fetching "${title}" (depth ${depth})…`;
        const neigh = await fetchLinks(title);
        neigh.forEach(tgt => {
          if (!nodesMap.has(tgt)) nodesMap.set(tgt, {id: tgt, group: depth + 1});
          links.push({source: title, target: tgt});
          if (depth < maxDepth) queue.push({title: tgt, depth: depth + 1});
        });
      }
      statusEl.textContent = `Done: ${nodesMap.size} nodes, ${links.length} links.`;
      return {nodes: Array.from(nodesMap.values()), links};
    }

    function draw({nodes, links}) {
      statusEl.textContent = 'Rendering graph…';
      container.selectAll('*').remove();

      const width  = +svg.node().clientWidth;
      const height = +svg.node().clientHeight;
      const color  = d3.scaleOrdinal(d3.schemeCategory10);

      const sim = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(60).strength(0.1))
        .force('charge', d3.forceManyBody().strength(-50))
        .force('center', d3.forceCenter(width/2, height/2))
        .alphaDecay(0.05) // higher decay → faster stabilization
        .velocityDecay(0.8);

      const link = container.append('g')
        .attr('stroke','#aaa')
        .selectAll('line')
        .data(links)
        .join('line');

      const node = container.append('g')
        .attr('stroke','#fff')
        .attr('stroke-width',1.5)
        .selectAll('circle')
        .data(nodes)
        .join('circle')
          .attr('r', 6)
          .attr('fill', d => color(d.group))
          .call(d3.drag()
            .on('start', (e,d) => {
              if (!e.active) sim.alphaTarget(0.3).restart();
              d.fx=d.x; d.fy=d.y;
            })
            .on('drag',  (e,d) => { d.fx=e.x; d.fy=e.y; })
            .on('end',   (e,d) => {
              if (!e.active) sim.alphaTarget(0);
              d.fx=null; d.fy=null;
            }))
          .on('mouseover', (e,d) => {
            tooltipEl
              .style('display','block')
              .text(d.id);
          })
          .on('mousemove', (e) => {
            tooltipEl
              .style('top',  (e.pageY+10)+'px')
              .style('left', (e.pageX+10)+'px');
          })
          .on('mouseout', () => {
            tooltipEl.style('display','none');
          });

      sim.on('tick', () => {
        link
          .attr('x1', d=>d.source.x)
          .attr('y1', d=>d.source.y)
          .attr('x2', d=>d.target.x)
          .attr('y2', d=>d.target.y);

        node
          .attr('cx', d=>d.x)
          .attr('cy', d=>d.y);
      });

      statusEl.textContent = 'Graph ready.';
    }

    goBtn.addEventListener('click', async () => {
      const start = document.getElementById('startPage').value.trim();
      const depth = +depthSlider.value;
      if (!start) return alert('Enter a start page.');
      const graph = await crawl(start, depth);
      draw(graph);
    });
  </script>
</body>
</html>
