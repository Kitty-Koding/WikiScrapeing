<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Wikipedia Link Graph Explorer</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 1em; }
    input, button { padding: 0.5em; margin: 0.5em 0; }
    label { display: block; margin-top: 1em; }
    #status { margin: .5em 0; color: #555; white-space: pre; }
    svg { width: 100%; height: 80vh; border: 1px solid #ccc; }
    #tooltip {
      position: absolute; pointer-events: none;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px; border: 1px solid #999;
      border-radius: 4px; font-size: 12px; display: none;
    }
  </style>
</head>
<body>
  <h1>Wikipedia Link Graph Explorer</h1>

  <label>
    Starting page:
    <input type="text" id="startPage" placeholder="e.g. JavaScript">
  </label>
  <label>
    Depth (1â€“8):
    <input type="range" id="depthSlider" min="1" max="8" value="2">
    <span id="depthValue">2</span>
  </label>
  <button id="goBtn">Generate Graph</button>
  <div id="status">Idle.</div>

  <div id="tooltip"></div>
  <svg id="graph"></svg>

  <!-- D3 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    const depthSlider = document.getElementById('depthSlider');
    const depthValue  = document.getElementById('depthValue');
    const statusEl    = document.getElementById('status');
    const goBtn       = document.getElementById('goBtn');
    const tooltipEl   = d3.select('#tooltip');
    const svg         = d3.select('#graph');
    const container   = svg.append('g');

    depthSlider.addEventListener('input', () => {
      depthValue.textContent = depthSlider.value;
    });

    // Zoom & pan
    const ZOOM_LABEL_THRESHOLD = 1.5;
    svg.call(d3.zoom()
      .scaleExtent([0.1, 4])
      .on('zoom', ({transform}) => {
        container.attr('transform', transform);
        container.selectAll('text')
          .style('display', transform.k >= ZOOM_LABEL_THRESHOLD ? 'block' : 'none');
      }));

    let simulation, allNodes = [], allLinks = [];

    async function fetchLinks(title) {
      const enc = encodeURIComponent(title), all = [];
      let cont = '';
      do {
        const url = `https://en.wikipedia.org/w/api.php` +
                    `?action=query&prop=links&titles=${enc}` +
                    `&pllimit=max&format=json&origin=*${cont}`;
        const j = await (await fetch(url)).json();
        const p = Object.values(j.query.pages)[0];
        if (p.links) {
          p.links.forEach(l => {
            if (!/^(Category|Wikipedia|Help|File|Portal|Special|Template):/.test(l.title))
              all.push(l.title);
          });
        }
        cont = j.continue ? `&plcontinue=${j.continue.plcontinue}` : '';
      } while (cont);
      return Array.from(new Set(all));
    }

    function initializeGraph() {
      container.selectAll('*').remove();
      allNodes = [];
      allLinks = [];

      simulation = d3.forceSimulation()
        .force('link', d3.forceLink().id(d => d.id).distance(60).strength(0.1))
        .force('charge', d3.forceManyBody().strength(-40))
        .force('center', d3.forceCenter(svg.node().clientWidth / 2, svg.node().clientHeight / 2))
        .alphaDecay(0.03);

      const linkGroup = container.append('g')
        .attr('stroke', '#aaa')
        .attr('stroke-opacity', 0.2)
        .selectAll('line');

      const nodeGroup = container.append('g')
        .selectAll('circle');

      const labelGroup = container.append('g')
        .selectAll('text');

      simulation.on('tick', () => {
        container.selectAll('line')
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);

        container.selectAll('circle')
          .attr('cx', d => d.x)
          .attr('cy', d => d.y);

        container.selectAll('text')
          .attr('x', d => d.x + 8)
          .attr('y', d => d.y + 4);
      });
    }

    function addToGraph(newNodes, newLinks) {
      const existingNodeIds = new Set(allNodes.map(n => n.id));
      const filteredNodes = newNodes.filter(n => !existingNodeIds.has(n.id));
      allNodes.push(...filteredNodes);
      allLinks.push(...newLinks);

      simulation.nodes(allNodes);
      simulation.force('link').links(allLinks);
      simulation.alpha(0.5).restart();

      const color = d3.scaleOrdinal(d3.schemeCategory10);

      const node = container.selectAll('circle')
        .data(allNodes, d => d.id)
        .join('circle')
          .attr('r', 6)
          .attr('fill', d => color(d.depth))
          .attr('cx', svg.node().clientWidth / 2 + Math.random() * 20 - 10)
          .attr('cy', svg.node().clientHeight / 2 + Math.random() * 20 - 10)
          .on('mouseover', (e, d) => {
            tooltipEl.style('display','block').text(d.id);
          })
          .on('mousemove', (e) => {
            tooltipEl.style('top',  (e.pageY + 10)+'px')
                     .style('left', (e.pageX + 10)+'px');
          })
          .on('mouseout', () => {
            tooltipEl.style('display','none');
          })
          .call(d3.drag()
            .on('start', (e,d) => {
              if (!e.active) simulation.alphaTarget(0.3).restart();
              d.fx = d.x; d.fy = d.y;
            })
            .on('drag', (e,d) => { d.fx = e.x; d.fy = e.y; })
            .on('end', (e,d) => {
              if (!e.active) simulation.alphaTarget(0);
              d.fx = null; d.fy = null;
            }));

      container.selectAll('text')
        .data(allNodes, d => d.id)
        .join('text')
          .text(d => d.id)
          .attr('font-size','9px')
          .style('display', 'none');
    }

    async function crawlAndBuild(start, maxDepth) {
      initializeGraph();
      const queue = [{title: start, depth: 0}];
      const seen = new Set([start]);

      while (queue.length) {
        const current = queue.shift();
        statusEl.textContent = `Fetching "${current.title}" (depth ${current.depth}) - Queue: ${queue.length}`;

        const links = await fetchLinks(current.title);
        const newNodes = [], newLinks = [];

        for (const l of links) {
          newLinks.push({source: current.title, target: l});
          if (!seen.has(l) && current.depth + 1 <= maxDepth) {
            queue.push({title: l, depth: current.depth + 1});
            seen.add(l);
            newNodes.push({id: l, depth: current.depth + 1});
          }
        }

        addToGraph(
          [{id: current.title, depth: current.depth}, ...newNodes],
          newLinks
        );
      }

      statusEl.textContent = `Done. Nodes: ${allNodes.length}, Links: ${allLinks.length}`;
    }

    goBtn.addEventListener('click', () => {
      const start = document.getElementById('startPage').value.trim();
      const depth = +depthSlider.value;
      if (!start) return alert('Enter a start page.');
      crawlAndBuild(start, depth);
    });
  </script>
</body>
</html>
