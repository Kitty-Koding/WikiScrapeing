<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Wikipedia Link Graph Explorer</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 1em; }
    input, button { padding: 0.5em; margin: 0.5em 0; }
    label { display: block; margin-top: 1em; }
    #status { margin: .5em 0; color: #555; white-space: pre; }
    svg { width: 100%; height: 80vh; border: 1px solid #ccc; }
    #tooltip {
      position: absolute; pointer-events: none;
      background: rgba(255,255,255,0.9);
      padding: 4px 8px; border: 1px solid #999;
      border-radius: 4px; font-size: 12px; display: none;
    }
  </style>
</head>
<body>
  <h1>Wikipedia Link Graph Explorer</h1>

  <label>
    Starting page:
    <input type="text" id="startPage" placeholder="e.g. JavaScript">
  </label>
  <label>
    Depth (2–6):
    <input type="range" id="depthSlider" min="2" max="6" value="2">
    <span id="depthValue">2</span>
  </label>
  <button id="goBtn">Generate Graph</button>
  <div id="status">Idle.</div>

  <div id="tooltip"></div>
  <svg id="graph"></svg>

  <!-- D3 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    const depthSlider = document.getElementById('depthSlider');
    const depthValue  = document.getElementById('depthValue');
    const statusEl    = document.getElementById('status');
    const goBtn       = document.getElementById('goBtn');
    const tooltipEl   = d3.select('#tooltip');
    const svg         = d3.select('#graph');
    const container   = svg.append('g');

    depthSlider.addEventListener('input', () => {
      depthValue.textContent = depthSlider.value;
    });

    // Zoom & pan + label toggle
    const ZOOM_LABEL_THRESHOLD = 1.5;
    svg.call(d3.zoom()
      .scaleExtent([0.1, 4])
      .on('zoom', ({transform, sourceEvent}) => {
        container.attr('transform', transform);
        // toggle labels based on zoom scale
        container.selectAll('text')
          .style('display', transform.k >= ZOOM_LABEL_THRESHOLD ? 'block' : 'none');
      }));

    async function fetchLinks(title) {
      const enc = encodeURIComponent(title), all = [];
      let cont = '';
      do {
        const url = `https://en.wikipedia.org/w/api.php` +
                    `?action=query&prop=links&titles=${enc}` +
                    `&pllimit=max&format=json&origin=*${cont}`;
        const j = await (await fetch(url)).json();
        const p = Object.values(j.query.pages)[0];
        if (p.links) {
          p.links.forEach(l => {
            if (!/^(Category|Wikipedia|Help|File|Portal|Special|Template):/.test(l.title))
              all.push(l.title);
          });
        }
        cont = j.continue ? `&plcontinue=${j.continue.plcontinue}` : '';
      } while (cont);
      return Array.from(new Set(all));
    }

    // BFS by depth to compute per-level counts
    async function crawl(start, maxDepth) {
      statusEl.textContent = 'Crawling…';
      const nodesMap = new Map(), links = [];
      const levels = [[start]];
      nodesMap.set(start, {id: start, depth: 0});

      for (let depth = 0; depth <= maxDepth; depth++) {
        const current = levels[depth] || [];
        const total   = current.length;
        if (!total) continue;
        const next    = [];

        for (let i = 0; i < total; i++) {
          const title = current[i];
          statusEl.textContent = 
            `(depth ${depth}) – ` +
            `${i+1}/${total} (${Math.round((i+1)/total*100)}%) -`+`Fetching "${title}"` ;

          const neigh = await fetchLinks(title);
          neigh.forEach(tgt => {
            if (!nodesMap.has(tgt)) {
              nodesMap.set(tgt, {id: tgt, depth: depth+1});
              if (depth+1 <= maxDepth) next.push(tgt);
            }
            links.push({source: title, target: tgt});
          });
        }
        levels[depth+1] = next;
      }

      statusEl.textContent = 
        `Done crawl:\n` +
        `• Nodes: ${nodesMap.size}\n` +
        `• Links: ${links.length}`;
      return {nodes: Array.from(nodesMap.values()), links};
    }

    function draw({nodes, links}) {
      statusEl.textContent = 'Rendering graph…';
      container.selectAll('*').remove();

      const width  = +svg.node().clientWidth;
      const height = +svg.node().clientHeight;
      const color  = d3.scaleOrdinal(d3.schemeCategory10);

      const sim = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d=>d.id).distance(60).strength(0.1))
        .force('charge', d3.forceManyBody().strength(-50))
        .force('center', d3.forceCenter(width/2, height/2))
        .alphaDecay(0.05);

      // links with low opacity
      container.append('g')
        .attr('stroke','#aaa')
        .attr('stroke-opacity', 0.2)
        .selectAll('line')
        .data(links)
        .join('line');

      // nodes without stroke
      const node = container.append('g')
        .selectAll('circle')
        .data(nodes)
        .join('circle')
          .attr('r', 6)
          .attr('fill', d => color(d.depth))
          .on('mouseover', (e,d) => {
            tooltipEl
              .style('display','block')
              .text(d.id);
          })
          .on('mousemove', (e) => {
            tooltipEl
              .style('top',  (e.pageY+10)+'px')
              .style('left', (e.pageX+10)+'px');
          })
          .on('mouseout', () => {
            tooltipEl.style('display','none');
          })
          .call(d3.drag()
            .on('start', (e,d) => {
              if (!e.active) sim.alphaTarget(0.3).restart();
              d.fx = d.x; d.fy = d.y;
            })
            .on('drag',  (e,d) => { d.fx = e.x; d.fy = e.y; })
            .on('end',   (e,d) => {
              if (!e.active) sim.alphaTarget(0);
              d.fx = null; d.fy = null;
            }));

      // hidden labels initially
      container.append('g')
        .selectAll('text')
        .data(nodes)
        .join('text')
          .text(d => d.id)
          .attr('font-size','9px')
          .attr('dx',8).attr('dy',4)
          .style('display','none');

      sim.on('tick', () => {
        container.selectAll('line')
          .attr('x1', d=>d.source.x)
          .attr('y1', d=>d.source.y)
          .attr('x2', d=>d.target.x)
          .attr('y2', d=>d.target.y);

        node
          .attr('cx', d=>d.x)
          .attr('cy', d=>d.y);

        container.selectAll('text')
          .attr('x', d=>d.x)
          .attr('y', d=>d.y);
      });

      statusEl.textContent = 'Graph ready. Zoom in ≥'+ZOOM_LABEL_THRESHOLD+'× to see labels.';
    }

    goBtn.addEventListener('click', async () => {
      const start = document.getElementById('startPage').value.trim();
      const depth = +depthSlider.value;
      if (!start) return alert('Enter a start page.');
      const graph = await crawl(start, depth);
      draw(graph);
    });
  </script>
</body>
</html>
