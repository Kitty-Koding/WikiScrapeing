<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Wikipedia Crawler</title>
  <style>
    :root {
      --primary: #2c3e50;
      --accent: #18bc9c;
      --bg: #ecf0f1;
      --text: #34495e;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; font-family: 'Segoe UI', sans-serif;
      background: var(--bg); color: var(--text);
      display: flex; flex-direction: column; align-items: center;
      padding: 1em;
    }
    h1 { color: var(--primary); }
    .controls {
      background: #fff; padding: 1em; border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      width: 100%; max-width: 480px;
    }
    .controls label {
      display: block; margin: 0.5em 0 0.2em;
    }
    .controls input[type="text"],
    .controls input[type="range"] {
      width: 100%; padding: 0.4em; border: 1px solid #ccc;
      border-radius: 4px;
    }
    .controls .buttons {
      margin-top: 1em;
      display: flex; gap: 0.5em;
    }
    .controls button {
      flex: 1; padding: 0.6em; background: var(--accent);
      color: white; border: none; border-radius: 4px;
      cursor: pointer; font-size: 1em;
    }
    .controls button:disabled { opacity: 0.6; cursor: not-allowed; }
    #progress-wrap {
      margin: 1em 0; width: 100%; max-width: 480px;
    }
    progress {
      width: 100%; height: 1.2em;
      appearance: none;
    }
    progress::-webkit-progress-bar {
      background: #ddd; border-radius: 4px;
    }
    progress::-webkit-progress-value {
      background: var(--accent);
      border-radius: 4px;
    }
    #status, #eta, #filesizes {
      margin: 0.5em 0;
      font-size: 0.9em;
      text-align: center;
    }
    #filesizes span { display: block; }
  </style>
</head>
<body>
  <h1>Wikipedia Crawler</h1>
  <div class="controls">
    <label for="startPage">Start Page</label>
    <input type="text" id="startPage" value="JavaScript">
    <label for="depth">Depth (1–8): <span id="depthVal">2</span></label>
    <input type="range" id="depth" min="1" max="8" value="2">
    <div class="buttons">
      <button id="startBtn">Start Crawl</button>
      <button id="downloadBtn" disabled>Download for Gephi</button>
    </div>
  </div>

  <div id="progress-wrap">
    <progress id="progress" value="0" max="1"></progress>
  </div>
  <div id="status">Idle.</div>
  <div id="eta"></div>
  <div id="filesizes"></div>

  <script>
  (()=>{
    const startBtn    = document.getElementById('startBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const startInput  = document.getElementById('startPage');
    const depthSlider = document.getElementById('depth');
    const depthVal    = document.getElementById('depthVal');
    const progressBar = document.getElementById('progress');
    const statusEl    = document.getElementById('status');
    const etaEl       = document.getElementById('eta');
    const sizesEl     = document.getElementById('filesizes');

    depthSlider.oninput = () => depthVal.textContent = depthSlider.value;

    // concurrency controlled BFS
    async function crawl(start, maxDepth) {
      const queue = [{id: start, depth:0}];
      const visited = new Set([start]);
      const nodes = [], links = [];
      let totalToProcess = 1, done = 0;
      let startTime = performance.now(), avgFetch = 0;

      statusEl.textContent = 'Initializing…';
      updateProgress();

      const concurrency = 5;
      let active = 0;

      return new Promise(resolve => {
        function next() {
          while (active < concurrency && queue.length) {
            const {id, depth} = queue.shift();
            active++;
            fetchLinks(id).then(neigh => {
              const t0 = performance.now();
              // record node
              nodes.push({ id, depth });
              neigh.forEach(nb => {
                links.push({ source: id, target: nb });
                if (!visited.has(nb) && depth+1<=maxDepth) {
                  visited.add(nb);
                  queue.push({id: nb, depth: depth+1});
                  totalToProcess++;
                }
              });
              // update stats
              done++; active--;
              const t1 = performance.now();
              avgFetch = ((avgFetch*(done-1)) + (t1-t0)) / done;
              updateProgress();
              if (queue.length || active) next();
              else resolve({nodes, links});
            }).catch(err=>{
              console.error(err);
              done++; active--;
              updateProgress();
              if (queue.length || active) next();
              else resolve({nodes, links});
            });
          }
        }
        next();
      });

      function updateProgress() {
        statusEl.textContent = `Processed ${done}/${totalToProcess}`;
        progressBar.max = totalToProcess;
        progressBar.value = done;
        const rem = totalToProcess - done;
        const eta = rem * avgFetch;
        const sec = Math.round(eta/1000);
        etaEl.textContent = avgFetch
          ? `ETA: ${Math.floor(sec/60)}m ${sec%60}s`
          : '';
      }
    }

    async function fetchLinks(title) {
      const enc = encodeURIComponent(title);
      let cont='', out=new Set();
      do {
        const url = `https://en.wikipedia.org/w/api.php`+
          `?action=query&prop=links&titles=${enc}`+
          `&pllimit=max&format=json&origin=*${cont}`;
        const res = await fetch(url);
        const j = await res.json();
        const page = Object.values(j.query.pages)[0];
        if (page.links) {
          page.links.forEach(l=>{
            if (!/^(Category|Wikipedia|Help|File|Portal|Special|Template):/.test(l.title))
              out.add(l.title);
          });
        }
        cont = j.continue ? `&plcontinue=${j.continue.plcontinue}` : '';
      } while(cont);
      return Array.from(out);
    }

    // build CSV & trigger download, measure size via Blob
    function prepareAndEnableDownload(nodes, links) {
      // nodes.csv
      const nodeCsv = ['Id,Label,Depth']
        .concat(nodes.map(n=>`"${n.id}","${n.id}",${n.depth}`))
        .join('\n');
      const nodeBlob = new Blob([nodeCsv], {type:'text/csv'});
      // edges.csv
      const edgeCsv = ['Source,Target']
        .concat(links.map(l=>`"${l.source}","${l.target}"`))
        .join('\n');
      const edgeBlob = new Blob([edgeCsv], {type:'text/csv'});

      // show sizes
      sizesEl.innerHTML = `
        <span>nodes.csv: ${(nodeBlob.size/1024).toFixed(1)} KB</span>
        <span>edges.csv: ${(edgeBlob.size/1024).toFixed(1)} KB</span>`;

      // hook download
      downloadBtn.onclick = ()=>{
        triggerDownload(nodeBlob,'nodes.csv');
        triggerDownload(edgeBlob,'edges.csv');
      };
      downloadBtn.disabled = false;
    }

    function triggerDownload(blob, name) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = name;
      a.click();
      URL.revokeObjectURL(url);
    }

    // main
    startBtn.onclick = async ()=> {
      startBtn.disabled = downloadBtn.disabled = true;
      sizesEl.textContent = etaEl.textContent = '';
      statusEl.textContent = 'Starting crawl…';
      const { nodes, links } = await crawl(startInput.value.trim(), +depthSlider.value);
      statusEl.textContent = `Done: ${nodes.length} nodes, ${links.length} links.`;
      prepareAndEnableDownload(nodes, links);
      startBtn.disabled = false;
    };
  })();
  </script>
</body>
</html>
